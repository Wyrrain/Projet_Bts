package com.julio.nfc20;

import android.app.PendingIntent;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.nfc.NdefMessage;
import android.nfc.NdefRecord;
import android.nfc.NfcAdapter;

import android.nfc.Tag;
import android.nfc.tech.NfcV;
import android.os.Parcelable;
import android.os.Vibrator;
import android.provider.Settings;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.Toast;
import android.widget.ToggleButton;
import android.widget.ViewSwitcher;
//import android.widget.Toolbar;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;

public class NFCScan extends AppCompatActivity {

    private boolean tagReaded;

    private final int nAcces = 8;
    private  final String charSet = "ISO-8859-1";


    public static final String TAG = "NfcDemo";

    private TextView mTextView;
    private NfcAdapter mNfcAdapter;
    private TextView  mMsgNFC;
    private Vibrator vibe;
    private int vibrationDuration;

    private SharedPreferences preferences;
    private SharedPreferences.Editor preferencesEditor;

    private static final int PREFERENCE_MODE_PRIVATE = 0;
    private static final String MY_UNIQUE_PREFERENCE_FILE = "RFIDCostumesPreferences";

    private RelativeLayout layoutReadWrite;
    private ToggleButton tglReadWrite;
    private TextView txtReadWriteMode;
    private ImageButton btnClearFields;

    private TextView txtLabelLigne1;
    private TextView txtLabelLigne2;
    private TextView txtLabelLigne3;
    private TextView txtLabelLigne4;
    private TextView txtLabelLigne5;

    private EditText editTagLigne1;
    private EditText editTagLigne2;
    private EditText editTagLigne3;
    private EditText editTagLigne4;
    private EditText editTagLigne5;
    private ToggleButton tglAcces1;
    private ToggleButton tglAcces2;
    private ToggleButton tglAcces3;
    private ToggleButton tglAcces4;
    private ToggleButton tglAcces5;
    private ToggleButton tglAcces6;
    private ToggleButton tglAcces7;
    private ToggleButton tglAcces8;

    private ToggleButton[] tglAcces; //tableau de références aux 8 ToggleButton précédentes

    private TextView txtTagLigne1;
    private TextView txtTagLigne2;
    private TextView txtTagLigne3;
    private TextView txtTagLigne4;
    private TextView txtTagLigne5;
    private ImageView imgAcces1;
    private ImageView imgAcces2;
    private ImageView imgAcces3;
    private ImageView imgAcces4;
    private ImageView imgAcces5;
    private ImageView imgAcces6;
    private ImageView imgAcces7;
    private ImageView imgAcces8;

    private ImageView[] imgAcces; //tableau de références aux 8 ImageView précédentes
    private boolean[] accesState;

    private TextView txtAcces1;
    private TextView txtAcces2;
    private TextView txtAcces3;
    private TextView txtAcces4;
    private TextView txtAcces5;
    private TextView txtAcces6;
    private TextView txtAcces7;
    private TextView txtAcces8;
    private TextView txtTglAcces1;
    private TextView txtTglAcces2;
    private TextView txtTglAcces3;
    private TextView txtTglAcces4;
    private TextView txtTglAcces5;
    private TextView txtTglAcces6;
    private TextView txtTglAcces7;
    private TextView txtTglAcces8;

    private ViewSwitcher viewSwitcherLigne1;
    private ViewSwitcher viewSwitcherLigne2;
    private ViewSwitcher viewSwitcherLigne3;
    private ViewSwitcher viewSwitcherLigne4;
    private ViewSwitcher viewSwitcherLigne5;

    private ViewSwitcher viewSwitcherAcces;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_nfcscan);


        mTextView = findViewById(R.id.textView_explanation);

        mNfcAdapter = NfcAdapter.getDefaultAdapter(this);

        //mMsgNFC = findViewById(R.id.msgNFC);

        if (mNfcAdapter == null) {
            // Stop here, we definitely need NFC
            Toast.makeText(this, "", Toast.LENGTH_SHORT).show();Toast.makeText(this, "This device doesn't support NFC.", Toast.LENGTH_LONG).show();
            finish();
            return;

        }

       /* if (!mNfcAdapter.isEnabled()) {
            mTextView.setText("NFC is disabled.");
        } else {
            mTextView.setText("NFC is enable");
            onResume();

        }*/
        vibe = (Vibrator) NFCScan.this.getSystemService(Context.VIBRATOR_SERVICE);
        vibrationDuration = 20;
        onResume();

        //handleIntent(getIntent());
    }
    @Override
    protected void onResume() {

        super.onResume();

        if (!mNfcAdapter.isEnabled()) {
            //Toast.makeText(getApplicationContext(), "Vous devez activer la fonction NFC de votre smartphone pour utiliser cette application.", Toast.LENGTH_LONG).show();

            AlertDialog.Builder builder = new AlertDialog.Builder(NFCScan.this);
            builder.setTitle("NFC désactivé");
            builder.setMessage("Vous devez activer la fonction NFC de votre smartphone pour lire ou écrire des TAG.");
            builder.setPositiveButton("OK", new DialogInterface.OnClickListener() {
                public void onClick(DialogInterface dialog, int which) {
                    startActivity(new Intent(Settings.ACTION_NFC_SETTINGS));
                }
            });
            builder.show();
        }

        enableForegroundDispatcher();

    }
    @Override
    protected  void onPause() {

        super.onPause();

        disableForegroundDispatcher();
    }

    private Tag currentTag;

    @Override
    protected void onNewIntent(Intent intent) {

        super.onNewIntent(intent);

        String action = intent.getAction();

        if (NfcAdapter.ACTION_TAG_DISCOVERED.equals(action) || NfcAdapter.ACTION_TECH_DISCOVERED.equals(action)) {

            currentTag = (Tag) intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);

            if(!tglReadWrite.isChecked()) {
                readTagData(currentTag);
            }
            else {
                writeTagData(currentTag);
            }
        }
        else {

            Toast.makeText(this, "Tag illisible", Toast.LENGTH_LONG).show();
            tagReaded = false;
        }
    }

    private void enableForegroundDispatcher() {

        Intent intent = new Intent(this, MainActivity.class);
        intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);

        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, 0);
        IntentFilter[] intentFilter = new IntentFilter[]{};

        mNfcAdapter.enableForegroundDispatch(this, pendingIntent, intentFilter, null);
    }

    private void disableForegroundDispatcher() {

        mNfcAdapter.disableForegroundDispatch(this);
    }
    public void tglReadWriteOnClick(View view) {

        viewSwitcherLigne1.showNext();
        viewSwitcherLigne2.showNext();
        viewSwitcherLigne3.showNext();
        viewSwitcherLigne4.showNext();
        viewSwitcherLigne5.showNext();

        viewSwitcherAcces.showNext();

        RefreshModeReadWrite();
    }

    private void RefreshModeReadWrite() {

        if (!tglReadWrite.isChecked()) { // LIRE TAG

            layoutReadWrite.setBackgroundColor(Color.parseColor("#33ffffff"));
            txtReadWriteMode.setText("Lecture");
            txtReadWriteMode.setTextColor(Color.parseColor("#ffffffff"));
            btnClearFields.setVisibility(View.INVISIBLE);
        }
        else { // ECRIRE TAG

            layoutReadWrite.setBackgroundColor(Color.parseColor("#ffff0000"));
            txtReadWriteMode.setText("Ecriture");
            txtReadWriteMode.setTextColor(Color.parseColor("#ffffffff"));
            btnClearFields.setVisibility(View.VISIBLE);

            if(tagReaded) {

                String l1 = ((String)txtTagLigne1.getText()).replaceAll("\\u0000", "");
                String l2 = ((String)txtTagLigne2.getText()).replaceAll("\\u0000", "");
                String l3 = ((String)txtTagLigne3.getText()).replaceAll("\\u0000", "");
                String l4 = ((String)txtTagLigne4.getText()).replaceAll("\\u0000", "");
                String l5 = ((String)txtTagLigne5.getText()).replaceAll("\\u0000", "");

                editTagLigne1.setText(l1);
                editTagLigne2.setText(l2);
                editTagLigne3.setText(l3);
                editTagLigne4.setText(l4);
                editTagLigne5.setText(l5);

                for(int i=0; i<nAcces; i++) tglAcces[i].setChecked(accesState[i]);
            }
        }
    }
    private void readTagData(Tag tag) {

        byte[] id = tag.getId();

        for (String tech : tag.getTechList()) {

            if (tech.equals(NfcV.class.getName())) {

                // Get an instance of NfcV for the given tag:
                NfcV nfcvTag = NfcV.get(tag);

                try {
                    nfcvTag.connect();
                } catch (IOException e) {
                    return;
                }

                try {
                    /*
                    // Get system information (0x2B)
                    byte[] cmd = new byte[] {
                            (byte)0x00, // Flags
                            (byte)0x2B // Command: Get system information
                    };
                    byte[] systeminfo = nfcvTag.transceive(cmd);

                    // Chop off the initial 0x00 byte:
                    systeminfo = Arrays.copyOfRange(systeminfo, 1, 15);
                    */

                    // Read first 8 blocks containing the 32 byte of userdata defined in the Danish model
                    byte[] cmd = new byte[] {
                            (byte)0x00, // Flags
                            (byte)0x23, // Command: Read multiple blocks
                            (byte)0x00, // First block (offset)
                            (byte)0x1C  // Number of blocks
                    };
                    byte[] userdata = nfcvTag.transceive(cmd);

                    // Chop off the initial 0x00 byte:
                    userdata = Arrays.copyOfRange(userdata, 1, 112);

                    /*** DECODAGE DE LA TRAME ***/


                    int i;

                    /*** autorisations d'accès ***/

                    i = 2;

                    byte[] bufferAcces = new byte[4];

                    int bit = 1;
                    int codageAcces = 0;

                    for (int j = 0; j < 4; j++)
                    {
                        int byteVal = userdata[j + i];
                        if(byteVal < 0) byteVal = 256 + byteVal;
                        codageAcces += bit * byteVal;
                        bit *= 2;
                    }

                    bit = 1;

                    for (i = 0; i < nAcces; i++)
                    {
                        accesState[i] = ((codageAcces & bit) != 0);
                        setAcces(i, accesState[i]);
                        bit *= 2;
                    }

                    /*** rôles 1 à 5 ***/

                    i = 6;

                    byte[] buffer = new byte[18];
                    int iBuffer = 0;

                    while (userdata[i] != 0x00)
                    {
                        buffer[iBuffer] = userdata[i];
                        i++;
                        iBuffer++;
                    }
                    String tagL1 = new String(buffer, charSet);
                    txtTagLigne1.setText(tagL1);

                    i = 24;

                    buffer = new byte[18];
                    iBuffer = 0;

                    while (userdata[i] != 0x00)
                    {
                        buffer[iBuffer] = userdata[i];
                        i++;
                        iBuffer++;
                    }
                    String tagL2 = new String(buffer, charSet);
                    txtTagLigne2.setText(tagL2);

                    i = 42;

                    buffer = new byte[18];
                    iBuffer = 0;

                    while (userdata[i] != 0x00)
                    {
                        buffer[iBuffer] = userdata[i];
                        i++;
                        iBuffer++;
                    }
                    String tagL3 = new String(buffer, charSet);
                    txtTagLigne3.setText(tagL3);

                    i = 60;

                    buffer = new byte[18];
                    iBuffer = 0;

                    while (userdata[i] != 0x00)
                    {
                        buffer[iBuffer] = userdata[i];
                        i++;
                        iBuffer++;
                    }
                    String tagL4 = new String(buffer, charSet);
                    txtTagLigne4.setText(tagL4);

                    i = 78;

                    buffer = new byte[18];
                    iBuffer = 0;

                    while (userdata[i] != 0x00)
                    {
                        buffer[iBuffer] = userdata[i];
                        i++;
                        iBuffer++;
                    }
                    String tagL5 = new String(buffer, charSet);
                    txtTagLigne5.setText(tagL5);

                    /*** FIN - DECORTICAGE DE LA TRAME ***/

                    tagReaded = true;

                } catch (IOException e) {
                    Toast.makeText(getApplicationContext(), "Tag illisible", Toast.LENGTH_SHORT).show();
                    tagReaded = false;
                    return;
                }

                try {
                    nfcvTag.close();
                } catch (IOException e) {
                    return;
                }
            }
        }
    }
    private void writeTagData(Tag tag) {

        int i = 0;
        int indexBuffer = 0;

        byte[] message = new byte[100];

        int codageAcces = 0;

        if (tglAcces1.isChecked()) codageAcces += 1;
        if (tglAcces2.isChecked()) codageAcces += 2;
        if (tglAcces3.isChecked()) codageAcces += 4;
        if (tglAcces4.isChecked()) codageAcces += 8;
        if (tglAcces5.isChecked()) codageAcces += 16;
        if (tglAcces6.isChecked()) codageAcces += 32;
        if (tglAcces7.isChecked()) codageAcces += 64;
        if (tglAcces8.isChecked()) codageAcces += 128;

        message[2] = (byte)codageAcces;

        byte[] bTagL1 = (editTagLigne1.getText().toString() + "\0").getBytes(StandardCharsets.ISO_8859_1);
        byte[] bTagL2 = (editTagLigne2.getText().toString() + "\0").getBytes(StandardCharsets.ISO_8859_1);
        byte[] bTagL3 = (editTagLigne3.getText().toString() + "\0").getBytes(StandardCharsets.ISO_8859_1);
        byte[] bTagL4 = (editTagLigne4.getText().toString() + "\0").getBytes(StandardCharsets.ISO_8859_1);
        byte[] bTagL5 = (editTagLigne5.getText().toString() + "\0").getBytes(StandardCharsets.ISO_8859_1);

        indexBuffer = 6;
        for (i = 0; i < bTagL1.length; i++)
        {
            message[indexBuffer + i] = bTagL1[i];
            if (i == 16) break;
        }

        indexBuffer = 24;
        for (i = 0; i < bTagL2.length; i++)
        {
            message[indexBuffer + i] = bTagL2[i];
            if (i == 16) break;
        }

        indexBuffer = 42;
        for (i = 0; i < bTagL3.length; i++)
        {
            message[indexBuffer + i] = bTagL3[i];
            if (i == 16) break;
        }

        indexBuffer = 60;
        for (i = 0; i < bTagL4.length; i++)
        {
            message[indexBuffer + i] = bTagL4[i];
            if (i == 16) break;
        }

        indexBuffer = 78;
        for (i = 0; i < bTagL5.length; i++)
        {
            message[indexBuffer + i] = bTagL5[i];
            if (i == 16) break;
        }

        /*** CRC16 ***/

        byte[] CRC = CRC16.ComputeChecksumBytes(message, 96);

        for (i = 0; i < CRC.length; i++)
        {
            message[96 + i] = CRC[i];
        }

        for (String tech : tag.getTechList()) {

            if (tech.equals(NfcV.class.getName())) {

                // Get an instance of NfcV for the given tag:
                NfcV nfcvTag = NfcV.get(tag);

                try {
                    nfcvTag.connect();
                }
                catch (IOException e) {
                    Toast.makeText(getApplicationContext(), "Echec de connexion au Tag.", Toast.LENGTH_SHORT).show();
                    return;
                }

                try {
                    byte[] cmd;
                    byte firstBlockAddr;

                    for(i=0; i<25; i++) // 25 blocks de 4 pour aller jusqu'au 100ème octet
                    {
                        firstBlockAddr = (byte)i;

                        // Write Single Block (0x21)
                        cmd = new byte[] {
                                (byte)0x00,        // Flags
                                (byte)0x21,        // Command: write single block
                                firstBlockAddr,    // First block (offset)
                                message[(i*4)],    // trame >> octet 0
                                message[(i*4)+1],  // trame >> octet 1
                                message[(i*4)+2],  // trame >> octet 2
                                message[(i*4)+3]   // trame >> octet 3
                        };

                        byte[] response = nfcvTag.transceive(cmd);
                    }

                    Toast.makeText(getApplicationContext(), "Tag enregistré avec succès", Toast.LENGTH_SHORT).show();

                } catch (IOException e) {
                    Toast.makeText(getApplicationContext(), "L'enregistrement du Tag a échoué", Toast.LENGTH_SHORT).show();
                    return;
                }

                try {
                    nfcvTag.close();
                }
                catch (IOException e) {
                    return;
                }
            }
        }


    }

    private void setAcces(int i, boolean authorise) {

        if(authorise) imgAcces[i].setBackgroundResource(R.drawable.locked_off);
        else  imgAcces[i].setBackgroundResource(R.drawable.locked_on_circle);
    }

    private void setTglAcces(int i, boolean authorise) {

        tglAcces[i].setChecked(authorise);
    }




}



   /* private void processNFCData( Intent inputIntent ) {

        Parcelable[] rawMessages =
                inputIntent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES);

        if (rawMessages != null && rawMessages.length > 0) {

            NdefMessage[] messages = new NdefMessage[rawMessages.length];

            for (int i = 0; i < rawMessages.length; i++) {

                messages[i] = (NdefMessage) rawMessages[i];

            }
            Log.i(TAG, "message size = " + messages.length);


            // so you can just grab the first record.
            NdefMessage msg = (NdefMessage) rawMessages[0];

            // record 0 contains the MIME type, record 1 is the AAR, if present
            String payloadStringData = new String(msg.getRecords()[0].getPayload());

            // now do something with your payload payloadStringData
            mMsgNFC.setText(payloadStringData);
            //mMsgNFC.setText(msg);


        }

    }
    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);

        if (intent != null && NfcAdapter.ACTION_NDEF_DISCOVERED.equals( intent.getAction() )) {
            // We scanned an NFC Tag.
            processNFCData( intent );
        }
    }*/







